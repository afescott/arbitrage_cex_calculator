//! # Order Book Data Structures
//!
//! This module defines the core OrderBook data structure and its associated types.
//! The OrderBook manages:
//! - Concurrent bid and ask price levels using DashMap for lock-free operations
//! - Order tracking and management with unique order IDs
//! - Best bid/ask price calculation
//! - Transaction ID generation for order matching
//! - Last traded timestamp tracking
//!
//! The implementation uses concurrent data structures to support high-throughput
//! order processing in a multi-threaded environment.

use crossbeam_queue::SegQueue;
use dashmap::DashMap;
use pricelevel::{OrderId, PriceLevel, Side, UuidGenerator};
use std::{
    collections::BTreeMap,
    sync::{atomic::AtomicU64, Arc},
};
use uuid::Uuid;

#[warn(clippy::too_many_lines)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum FillType {
    /// Indicates a partial fill of an order
    Partial(Vec<OrderId>),

    /// Indicates a full fill of an order
    Full(Vec<OrderId>),
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum ExchangePriceList {
    Binance,
    Coinbase,
}

/// The OrderBook manages a collection of price levels for both bid and ask sides.
/// It supports adding, cancelling, and matching orders with lock-free operations where possible.
pub struct OrderBook {
    /// The symbol or identifier for this order book
    pub symbol: String,
    // BTreeMap keeps prices sorted (bids: highest first, asks: lowest first) and maps price â†’ quantity.
    pub exchange_bids_price_level: DashMap<(u64, ExchangePriceList), BTreeMap<u64, u64>>,

    pub exchange_asks_price_level: DashMap<(u64, ExchangePriceList), BTreeMap<u64, u64>>,
}

impl OrderBook {
    pub fn new(symbol: String) -> Self {
        Self {
            symbol,
            exchange_bids_price_level: DashMap::new(),
            exchange_asks_price_level: DashMap::new(),
        }
    }

  pub fn best_bid(&self) -> Option<u64> {
        let cached = self
            .cached_best_bid
            .load(std::sync::atomic::Ordering::Relaxed);
        if cached > 0 {
            // Verify the cached price still has orders
            if let Some(price_level) = self.bids.get(&cached) {
                if price_level.order_count() > 0 {
                    return Some(cached);
                }
            }
        }

        // Fallback to full scan and update cache
        let mut best_price = None;
        for item in self.bids.iter() {
            let price = *item.key();
            let price_level = item.value();

            if price_level.order_count() > 0
                && (best_price.is_none() || price > best_price.unwrap())
            {
                best_price = Some(price);
            }
        }

        if let Some(price) = best_price {
            self.cached_best_bid
                .store(price, std::sync::atomic::Ordering::Relaxed);
        } else {
            self.cached_best_bid
                .store(0, std::sync::atomic::Ordering::Relaxed);
        }

        best_price
    }

    pub fn best_ask(&self) -> Option<u64> {
        let cached = self
            .cached_best_ask
            .load(std::sync::atomic::Ordering::Relaxed);
        if cached < u64::MAX {
            // Verify the cached price still has orders
            if let Some(price_level) = self.asks.get(&cached) {
                if price_level.order_count() > 0 {
                    return Some(cached);
                }
            }
        }

        // Fallback to full scan and update cache
        let mut lowest_ask = None;
        for item in self.asks.iter() {
            let price = *item.key();
            let price_level = item.value();

            if price_level.order_count() > 0
                && (lowest_ask.is_none() || price < lowest_ask.unwrap())
            {
                lowest_ask = Some(price);
            }
        }

        if let Some(price) = lowest_ask {
            self.cached_best_ask
                .store(price, std::sync::atomic::Ordering::Relaxed);
        } else {
            self.cached_best_ask
                .store(u64::MAX, std::sync::atomic::Ordering::Relaxed);
        }

        lowest_ask
    }

    pub fn add_exchange_price_level(
        &self,
        price: u64,
        exchange: ExchangePriceList,
        side: Side,
        quantity: u64,
    ) {
        match side {
            Side::Buy => {
                let key = (price, exchange);
                let mut price_level = self
                    .exchange_bids_price_level
                    .entry(key)
                    .or_insert_with(BTreeMap::new);
                let entry = price_level.entry(price).or_insert(0);
                *entry += quantity;
            }
            Side::Sell => {
                let key = (price, exchange);
                let mut price_level = self
                    .exchange_asks_price_level
                    .entry(key)
                    .or_insert_with(BTreeMap::new);
                let entry = price_level.entry(price).or_insert(0);
                *entry += quantity;
            }
        }
    }
}

#[cfg(test)]
mod test {
    use std::{sync::Arc, time::Duration};

    use pricelevel::Side;
    use tokio::sync::mpsc::channel;

    use crate::orderbook::book::{ExchangePriceList, OrderBook};

    #[test]
    fn test_add_exchange_price_level_different_exchanges() {
        let order_book = OrderBook::new("BTC/USD".to_string());

        // Add same price to different exchanges - should be separate
        order_book.add_exchange_price_level(50000, ExchangePriceList::Binance, Side::Buy, 10);
        order_book.add_exchange_price_level(50000, ExchangePriceList::Coinbase, Side::Buy, 20);

        let binance_key = (50000, ExchangePriceList::Binance);
        let coinbase_key = (50000, ExchangePriceList::Coinbase);

        assert!(order_book
            .exchange_bids_price_level
            .contains_key(&binance_key));
        assert!(order_book
            .exchange_bids_price_level
            .contains_key(&coinbase_key));

        let binance_level = order_book
            .exchange_bids_price_level
            .get(&binance_key)
            .unwrap();
        let coinbase_level = order_book
            .exchange_bids_price_level
            .get(&coinbase_key)
            .unwrap();

        assert_eq!(binance_level.get(&50000), Some(&10));
        assert_eq!(coinbase_level.get(&50000), Some(&20));
    }

    #[test]
    fn test_add_exchange_price_level_bid() {
        let order_book = OrderBook::new("BTC/USD".to_string());

        // Add bid for Binance
        order_book.add_exchange_price_level(50000, ExchangePriceList::Binance, Side::Buy, 10);

        let key = (50000, ExchangePriceList::Binance);
        assert!(order_book.exchange_bids_price_level.contains_key(&key));

        let price_level = order_book.exchange_bids_price_level.get(&key).unwrap();
        assert_eq!(price_level.get(&50000), Some(&10));
    }

    #[test]
    fn test_add_exchange_price_level_ask() {
        let order_book = OrderBook::new("BTC/USD".to_string());

        // Add ask for Coinbase
        order_book.add_exchange_price_level(50100, ExchangePriceList::Coinbase, Side::Sell, 5);

        let key = (50100, ExchangePriceList::Coinbase);
        assert!(order_book.exchange_asks_price_level.contains_key(&key));

        let price_level = order_book.exchange_asks_price_level.get(&key).unwrap();
        assert_eq!(price_level.get(&50100), Some(&5));
    }

    #[test]
    fn test_add_exchange_price_level_quantity_accumulation() {
        let order_book = OrderBook::new("BTC/USD".to_string());

        // Add same price level multiple times - quantities should accumulate
        order_book.add_exchange_price_level(50000, ExchangePriceList::Binance, Side::Buy, 10);
        order_book.add_exchange_price_level(50000, ExchangePriceList::Binance, Side::Buy, 5);
        order_book.add_exchange_price_level(50000, ExchangePriceList::Binance, Side::Buy, 3);

        let key = (50000, ExchangePriceList::Binance);
        let price_level = order_book.exchange_bids_price_level.get(&key).unwrap();
        assert_eq!(price_level.get(&50000), Some(&18)); // 10 + 5 + 3
    }

    #[tokio::test]
    async fn test_add_exchange_price_level_concurrent() {
        let order_book = Arc::new(OrderBook::new("ETH/USD".to_string()));
        let book_1 = Arc::clone(&order_book);
        let book_2 = Arc::clone(&order_book);
        let (tx, mut rx) = channel::<u64>(1);

        let task = tokio::spawn(async move {
            book_1.add_exchange_price_level(2000, ExchangePriceList::Binance, Side::Sell, 13);

            let key = (2000, ExchangePriceList::Binance);
            let price_level = book_1.exchange_asks_price_level.get(&key).unwrap();
            let quantity = price_level.get(&2000).unwrap();

            tokio::time::sleep(Duration::from_secs(1)).await;

            tx.send(*quantity).await.unwrap();
        });

        let task_2 = tokio::spawn(async move {
            book_2.add_exchange_price_level(2000, ExchangePriceList::Binance, Side::Sell, 13);
        });

        tokio::join!(task, task_2);

        while let Some(val) = rx.recv().await {
            // Quantities should accumulate: 13 + 13 = 26
            assert_eq!(val, 26);
        }
    }
}
